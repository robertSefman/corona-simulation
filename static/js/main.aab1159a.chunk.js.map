{"version":3,"sources":["Population.js","App.js","serviceWorker.js","index.js"],"names":["Person","x","y","infected","dead","recovered","strokeColor","fillColor","cx","cy","r","style","fill","stroke","strokeWidth","Slider","label","value","setter","unit","editable","type","min","max","onChange","ev","target","step","createPopulation","width","height","Nrows","Math","ceil","yScale","d3","domain","range","widthScale","map","i","N","floor","xScale","key","hexoid","createRow","reduce","population","row","usePopulation","mortality","virality","lengthOfInfection","socialDistancing","reinfectability","useState","setPopulation","simulating","setSimulating","iterationCount","setIterationCount","useEffect","t","elapsedTime","nextPopulation","p","peopleDieOrGetBetter","contacts","contactKeys","includes","infectPeople","percentMovement","random","peopleMove","filter","person","candidate","extent","RADIUS","d","addAll","find","peopleCollisions","stop","startSimulation","length","stopSimulation","Population","defaultMortality","defaultVirality","defaultLengthOfInfection","defaultSocialDistancing","defaultReinfectability","setMortality","setVirality","setLengthOfInfection","setSocialDistancing","setReinfectability","onClick","App","query","URLSearchParams","window","location","search","className","get","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.aab1159a.chunk.js","sourcesContent":["import React, { useState, useEffect } from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport hexoid from \"hexoid\";\r\n\r\nconst RADIUS = 5;\r\n\r\nconst Person = ({ x, y, infected, dead, recovered }) => {\r\n  // I really should've used styled components :P\r\n  let strokeColor = \"rgb(146, 120, 226)\";\r\n  let fillColor = \"white\";\r\n\r\n  if (dead) {\r\n    return null;\r\n  }\r\n\r\n  if (infected !== null) {\r\n    strokeColor = \"rgb(246, 102, 64)\";\r\n    fillColor = \"rgb(246, 102, 64)\";\r\n  } else if (recovered) {\r\n    strokeColor = \"rgba(146, 119, 227, 0.5)\";\r\n    fillColor = \"rgba(146, 119, 227, 0.5)\";\r\n  }\r\n\r\n  return (\r\n    <circle\r\n      cx={x}\r\n      cy={y}\r\n      r={RADIUS}\r\n      style={{ fill: fillColor, stroke: strokeColor, strokeWidth: 2 }}\r\n    ></circle>\r\n  );\r\n};\r\n\r\nconst Slider = ({ label, value, setter, unit = \"%\", editable }) => {\r\n  return (\r\n    <p>\r\n      {label}:{\" \"}\r\n      {editable ? (\r\n        <input\r\n          type=\"range\"\r\n          min=\"0\"\r\n          max=\"100\"\r\n          value={value}\r\n          onChange={ev => setter(ev.target.value)}\r\n          step={1}\r\n        />\r\n      ) : null}\r\n      {value}\r\n      {unit}\r\n    </p>\r\n  );\r\n};\r\n\r\n// creates a row of population\r\nfunction createRow({ cx, cy, width }) {\r\n  // fit as many as possible into a row\r\n  const N = Math.floor(width / 15);\r\n\r\n  // point scale positions a row for us\r\n  const xScale = d3\r\n    .scalePoint()\r\n    .domain(d3.range(0, N))\r\n    .range([cx - width / 2, cx + width / 2]);\r\n\r\n  const row = d3.range(0, N).map(i => ({\r\n    x: xScale(i),\r\n    y: cy,\r\n    key: hexoid(25)(),\r\n    infected: null\r\n  }));\r\n\r\n  return row;\r\n}\r\n\r\n// generates a population oriented around (cx, cy)\r\n// fits into width and height\r\nfunction createPopulation({ cx, cy, width, height }) {\r\n  const Nrows = Math.ceil(height / 15);\r\n\r\n  const yScale = d3\r\n    .scalePoint()\r\n    .domain(d3.range(0, Nrows))\r\n    .range([cy - height / 2, cy + height / 2]);\r\n\r\n  // figure out how to make this create a circle\r\n  const widthScale = d3\r\n    .scaleLinear()\r\n    .domain([0, Nrows / 2, Nrows])\r\n    .range([15, width, 15]);\r\n\r\n  const rows = d3\r\n    .range(0, Nrows)\r\n    .map(i => createRow({ cx, cy: yScale(i), width: widthScale(i) }));\r\n\r\n  return rows.reduce((population, row) => [...population, ...row]);\r\n}\r\n\r\n// people tend to move around\r\n// this step makes that happen\r\nfunction peopleMove(population, socialDistancing) {\r\n  const percentMovement = 1 - socialDistancing / 100;\r\n\r\n  const random = d3.randomUniform(-3 * percentMovement, 3 * percentMovement);\r\n\r\n  return population.map(p =>\r\n    p.dead\r\n      ? p\r\n      : {\r\n          ...p,\r\n          x: p.x + random(),\r\n          y: p.y + random()\r\n        }\r\n  );\r\n}\r\n\r\n// when people collide, they transfer viruses\r\nfunction peopleCollisions(population) {\r\n  // we only care about infected people\r\n  const infected = population.filter(p => p.infected !== null);\r\n\r\n  // find people in vicinity of infected people\r\n  const collisions = infected.map(person => {\r\n    // subdivides whole space to find nearest candidates\r\n    const subdvidedSpace = d3\r\n      .quadtree()\r\n      .extent([\r\n        [-1, -1],\r\n        [RADIUS * 2, RADIUS * 2]\r\n      ])\r\n      .x(d => d.x)\r\n      .y(d => d.y)\r\n      .addAll(\r\n        // everyone not infected and not current lookup\r\n        population.filter(p => !p.infected).filter(p => p.key !== person.key)\r\n      );\r\n\r\n    // person within RADIUS*2 of lookup position\r\n    const candidate = subdvidedSpace.find(person.x, person.y, RADIUS * 2);\r\n\r\n    return candidate ? candidate : null;\r\n  });\r\n\r\n  return collisions.filter(p => p !== null);\r\n}\r\n\r\n// takes a population and list of contacts with infected folks\r\n// decides who got infected\r\n// we keep track of when you got infected with elapsedTime\r\nfunction infectPeople(\r\n  population,\r\n  contacts,\r\n  iterationCount,\r\n  virality,\r\n  reinfectability\r\n) {\r\n  const contactKeys = contacts.map(p => p.key);\r\n\r\n  return population.map(p => {\r\n    if (contactKeys.includes(p.key)) {\r\n      // this person came into contact with an infected fellow\r\n\r\n      if (p.recovered) {\r\n        // this person previously recovered\r\n        if (d3.randomUniform(0, 100)() < virality * (reinfectability / 100)) {\r\n          return {\r\n            ...p,\r\n            infected: iterationCount, // 100% infection rate\r\n            recovered: false\r\n          };\r\n        } else {\r\n          return p;\r\n        }\r\n      } else if (d3.randomUniform(0, 100)() < virality) {\r\n        return {\r\n          ...p,\r\n          infected: iterationCount, // 100% infection rate\r\n          recovered: false\r\n        };\r\n      } else {\r\n        return p;\r\n      }\r\n    } else {\r\n      return p;\r\n    }\r\n  });\r\n}\r\n\r\n// after N iterations you either die or improve\r\nfunction peopleDieOrGetBetter(\r\n  population,\r\n  iterationCount,\r\n  mortality,\r\n  lengthOfInfection\r\n) {\r\n  return population.map(p => {\r\n    if (p.infected) {\r\n      // infected people have a MORTALITY % chance of dying every day until they recover\r\n      if (d3.randomUniform(0, 1)() < mortality / lengthOfInfection) {\r\n        return {\r\n          ...p,\r\n          dead: true,\r\n          infected: null // so invisible dead people can't infect others\r\n        };\r\n      } else if (iterationCount - p.infected > lengthOfInfection) {\r\n        return {\r\n          ...p,\r\n          infected: null,\r\n          recovered: true\r\n        };\r\n      } else {\r\n        return p;\r\n      }\r\n    } else {\r\n      return p;\r\n    }\r\n  });\r\n}\r\n\r\nfunction usePopulation({\r\n  width,\r\n  height,\r\n  mortality,\r\n  virality,\r\n  lengthOfInfection,\r\n  socialDistancing,\r\n  reinfectability\r\n}) {\r\n  const [population, setPopulation] = useState(\r\n    createPopulation({\r\n      cx: width / 2,\r\n      cy: height / 2,\r\n      width: width - 15,\r\n      height: height - 15\r\n    })\r\n  );\r\n  // controls when the simulation is running\r\n  const [simulating, setSimulating] = useState(false);\r\n  const [iterationCount, setIterationCount] = useState(0);\r\n\r\n  function startSimulation() {\r\n    // avoid changing values directly\r\n    const nextPopulation = [...population];\r\n\r\n    // infect a random person\r\n    const person =\r\n      nextPopulation[Math.floor(Math.random() * nextPopulation.length)];\r\n\r\n    person.infected = 0;\r\n\r\n    setPopulation(nextPopulation);\r\n    setIterationCount(0);\r\n    setSimulating(true);\r\n  }\r\n\r\n  function stopSimulation() {\r\n    setSimulating(false);\r\n  }\r\n\r\n  // runs the simulation loop\r\n  useEffect(() => {\r\n    function iteratePopulation(elapsedTime) {\r\n      const iterationCount = Math.floor(elapsedTime / 60);\r\n      setPopulation(population => {\r\n        // calculate the next state of our population on each tick\r\n        let nextPopulation = [...population]; // avoid changin stuff directly\r\n\r\n        nextPopulation = peopleMove(nextPopulation, socialDistancing);\r\n        nextPopulation = infectPeople(\r\n          nextPopulation,\r\n          peopleCollisions(nextPopulation),\r\n          iterationCount,\r\n          virality,\r\n          reinfectability\r\n        );\r\n        nextPopulation = peopleDieOrGetBetter(\r\n          nextPopulation,\r\n          iterationCount,\r\n          mortality / 100,\r\n          lengthOfInfection\r\n        );\r\n\r\n        return nextPopulation;\r\n      });\r\n      setIterationCount(iterationCount);\r\n    }\r\n\r\n    if (simulating) {\r\n      const t = d3.timer(iteratePopulation);\r\n\r\n      // stop timer when cleaning up\r\n      return () => t.stop();\r\n    }\r\n  }, [\r\n    lengthOfInfection,\r\n    mortality,\r\n    reinfectability,\r\n    simulating,\r\n    socialDistancing,\r\n    virality\r\n  ]);\r\n\r\n  return {\r\n    population,\r\n    startSimulation,\r\n    stopSimulation,\r\n    simulating,\r\n    iterationCount\r\n  };\r\n}\r\n\r\nexport const Population = ({\r\n  width,\r\n  height,\r\n  defaultMortality = 4,\r\n  defaultVirality = 50,\r\n  defaultLengthOfInfection = 40,\r\n  defaultSocialDistancing = 0,\r\n  defaultReinfectability = 30\r\n}) => {\r\n  const [mortality, setMortality] = useState(defaultMortality);\r\n  const [virality, setVirality] = useState(defaultVirality);\r\n  const [lengthOfInfection, setLengthOfInfection] = useState(\r\n    defaultLengthOfInfection\r\n  );\r\n  const [socialDistancing, setSocialDistancing] = useState(\r\n    defaultSocialDistancing\r\n  );\r\n  const [reinfectability, setReinfectability] = useState(\r\n    defaultReinfectability\r\n  );\r\n\r\n  const {\r\n    population,\r\n    startSimulation,\r\n    stopSimulation,\r\n    simulating,\r\n    iterationCount\r\n  } = usePopulation({\r\n    width,\r\n    height,\r\n    mortality,\r\n    virality,\r\n    socialDistancing,\r\n    lengthOfInfection,\r\n    reinfectability\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <svg\r\n        style={{\r\n          width,\r\n          height\r\n        }}\r\n      >\r\n        {population.map(p => (\r\n          <Person {...p} />\r\n        ))}\r\n      </svg>\r\n      <div>\r\n        {simulating ? (\r\n          <button onClick={stopSimulation}>Stop</button>\r\n        ) : (\r\n          <button onClick={startSimulation}>Start simulation</button>\r\n        )}\r\n      </div>\r\n      <p>\r\n        Population: {population.filter(p => !p.dead).length}, Infected:{\" \"}\r\n        {population.filter(p => p.infected !== null).length}, Dead:{\" \"}\r\n        {population.filter(p => p.dead).length}, Recovered:{\" \"}\r\n        {population.filter(p => p.recovered).length}\r\n      </p>\r\n      {simulating ? <p>Iterations: {iterationCount}</p> : null}\r\n\r\n      <Slider\r\n        label=\"Social distancing\"\r\n        value={socialDistancing}\r\n        setter={setSocialDistancing}\r\n        editable={!simulating}\r\n      />\r\n      <Slider\r\n        label=\"Mortality\"\r\n        value={mortality}\r\n        setter={setMortality}\r\n        editable={!simulating}\r\n      />\r\n      <Slider\r\n        label=\"Virality\"\r\n        value={virality}\r\n        setter={setVirality}\r\n        editable={!simulating}\r\n      />\r\n      <Slider\r\n        label=\"Reinfectability\"\r\n        value={reinfectability}\r\n        setter={setReinfectability}\r\n        editable={!simulating}\r\n      />\r\n      <Slider\r\n        label=\"Length of infection\"\r\n        value={lengthOfInfection}\r\n        setter={setLengthOfInfection}\r\n        unit=\"steps\"\r\n        editable={!simulating}\r\n      />\r\n    </>\r\n  );\r\n};\r\n","import React from \"react\";\nimport { Population } from \"./Population\";\nfunction App() {\n  const query = new URLSearchParams(window.location.search);\n\n  return (\n    <div className=\"App\">\n      <h1>\n        {query.get(\"title\") ||\n          \"Visualizing the spread of viruses in a population\"}\n      </h1>\n      <Population\n        cx={400}\n        cy={200}\n        width={400}\n        height={300}\n        defaultMortality={query.get(\"mortality\") || 4}\n        defaultVirality={query.get(\"virality\") || 50}\n        defaultLengthOfInfection={query.get(\"lengthOfInfection\") || 40}\n        defaultSocialDistancing={query.get(\"socialDistancing\") || 0}\n        defaultReinfectability={query.get(\"reinfectability\") || 30}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}